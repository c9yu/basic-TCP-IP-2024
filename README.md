# basic-TCP-IP-2024
IoT 개발자 TCP/IP 학습 리포지토리

- 리눅스 조작
	- 경로 지정 관련
		- mkdir : 폴더 생성
		- cd 폴더명 : 폴더로 들어가기
		- cd : 초기 폴더로 돌아간다.
        - cd.. : 이전 경로로 돌아가기
		- ls : 현재 폴더에 있는 파일들의 목록을 보여준다.

	- 파일 관리
        - rm -rf 파일명 : 파일 삭제
		- nano 파일명 : 파일을 생성
		- sudo nano 파일명 : 파일을 수정
        - gcc 파일명 -o 실행파일명 : 컴파일
        - ./파일명 : 파일 실행
	
	- 세부 설정 변경
		- sudo nano /etc/nanorc 를 통해 설정창을 열어준다.
		- 줄번호 추가
			- linenumber 행의 주석을 제거해 준다.
        - backtab 크기 지정
            - backtab 행을 찾아서 숫자를 지정 (2가 적당하다)

    - 단축키
        - 복사
            - Shift + Ctrl + C
        - 붙여넣기
            - Shift + Ctrl + V
            

## 1일차 (2024-06-11)
- TCP/IP
	- IP
		- IPv4 : 4개의 byte로 구성되어 있다.
		- IPv6 : 향후 IPv4를 대체할 예정
	
		- 기본 게이트웨이 : 내 컴퓨터로 들어오는 출입문

	- 전송 방식
		- TCP / UDP
			- 통신 선로상에서 데이터(정보)가 흐른다.
		
			- TCP : 누락되는 데이터 없이 정확한 데이터의 전송이 필요한 경우 ex. 압축파일 등
			- UDP : 대용량으로 데이터를 전송해 한 두 개 잃어버려도 괜찮은 데이터 ex. 영상 등

- 네트워크 프로그래밍
	- 소말리아
		- 소 : 소켓 (Socket) : 전화기
		- 말 : 바인드 (Bind) : 전화번호
		- 리 : 리슨 (Listen) : 개통이 완료된 상태
		- 아 : 엑셉트 (Accept) : 통화(개통이 완료된 후)
	
	- Socket : 소켓 생성
	- Bind   : IP 주소와 PORT 번호 할당
	- Listen : 연결요청 가능상태로 변경
	- Accept : 연결요청에 대한 수락
	
	- 웹 통신이 이루어지는 원리
		- 특정한 키워드(데이터, 정보)를 서버에 보내면 해당 키워드에 해당하는 화면을 서버에서 보내준다.

    - 디스크립터
        - 주로 int fd의 형태로 선언하며, 특정 작업의 성공 여부에 따라 반환되는 값(0(성공), 1(실패))이 달라진다
        - 반환되는 값에 따라 다른 코드를 실행한다.

    - IPv4 기반의 주소표현을 위한 구조체
    ```
    struct sockaddr_in
    {
        sa_faaminly_t   sin_family;   // 주소체계 (Address Family)
        uint16_t        sin fort;     // 16비트 TCP/UDP PORT 번호
        struct in_addr  sin_addr;     // 32비트 IP 주소
        char            sin_zero[8];  // 사용되지 않음
    };

    struct in_addr
    {
        in_addr_t       s_addr;       // 32비트 IPv4 인터넷 주소
    }
    ```

    - 주소 체계
        - AF_INET IPv4 인터넷 프로토콜에 적용하는 주소체계
        - AF_INET6 IPv6 인터넷 프로토콜에 적용하는 주소체계
        - AF_LOCAL 로컬 통신을 위한 유닉스 프로토콜의 주소체계
    
    - 바이트 순서와 네트워크 바이트 순서
        - 리틀 엔디안/빅 엔디안
            - 작은 번지에 하위 바이트 값 : 리틀 엔디안
            - 작은 번지에 상위 바이트 값: 빅 엔디안

        - ex. 정수 0x12345678와, 0x20, 0x21, 0x22, 0x23 번지가 존재하는 경우
            - 0x12 : 최상위 바이트
            - 0x78 : 최하위 바이트

            - 0x20 : 최하위 번지
            - 0x23 : 최상위 번지

            - 즉, 최상위 바이트(0x12)가 최하위 번지(0x20)에 저장 : 빅 엔디안
            - 최하위 바이트(0x78)가 최하위 번지(0x20)에 저장 : 리틀 엔디안
    
## 2일차(2024-06-12)
## 2일차
- 인터넷 주소의 초기화

    ```c
    struct sockaddr_in addr;
    char* serv_ip = "211.217.168.13";
    char* serv_port = "9190";
    memset(&addr, 0, sizeof(addr)); // 구조체 변수 addr의 모든 멤버 0으로 초기화!
    addr.sin_family = AF_INET;      // 주소 체계 지정
    addr.sin_addr.s_addr = inet_addr(serv_ip)       // 문자열 기반의 IP주소 초기화
    addr.sin_port.s_addr = htons(atoi(serv_port));  // 문자열 기반의 PORT번호 초기화
    ```

    - memset 함수는 동일한 값으로 바이트단위 초기화를 할 때 호출하는 함수
    - 이 함수를 호출해서 addr을 전부 0으로 초기화하는 이유는
    - 0으로 초기화해야 하는 sockaddr_in 구조체 멤버 sin_zero를 0으로 초기화하기 위해서임!
    
- 서버 프로그램
    - sockaddr_in 구조체 변수 선언 > 서버 소켓이 동작하는 컴퓨터의 IP와 소켓에 부여할 PORT 번호로 초기화 > bind 함수 호출
- 클라이언트 프로그램
    - sockaddr_in 구조체 변수 선언 > 이를 연결할 서버 소켓의 IP와 PORT번호로 초기화 > connect 함수 호출

- INADDR_ANY 상수로 서버의 IP주소 할당

    ```c
        struct sockaddr_in addr;
        char* serv_port = "9190";
        memset(&addr, 0, sizeof(addr)); 
        addr.sin_family = AF_INET;      
        addr.sin_addr.s_addr = htonl(INADDR_ANY); // 소켓의 IP주소를 INADDR_ANY로 초기화할 경우, 소켓이 동작하는 컴퓨터의 IP주소가 자동으로 할당됨!
        addr.sin_port.s_addr = htons(atoi(serv_port));  
    ```

    - 이러면 컴퓨터 내에 두 개 이상의 IP 할당 받아 사용하는 경우(ex: Router)
    - 할당 받은 IP중 어떤 주소를 통해서 데이터가 들어오더라도 PORT 번호만 일치하면 수신 가능

- 루프팩 주소 - 127.0.0.1, 컴퓨터 자신의 IP주소

- 소켓에 인터넷 주소 할당
    - 초기화된 주소 정보를 소켓에 할당하는 bind 함수!

    ```c
    int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);
        // 성공 시 0, 실패 시 -1 반환
        // sockfd : 주소 정보를 (IP,PORT) 할당할 소켓의 파일 디스크립터
        // myaddr : 할당하고자 하는 주소정보를 지니는 구조체 변수의 주소 값
        // addrlen : 두 번째 인자로 전달된 구조체 변수의 길이 정보
    ```

- TCP/IP 프로토콜 스택
    1. LINK 계층
        - 물리적인 영역의 표준화에 대한 결과
        - LAN, WAN, MAN과 같은 네트워크 표준과 관련된 프로토콜을 정의하는 영역
    2. IP 계층
        - 목적지로 데이터를 전송하기 위해 어떤 경로를 거쳐갈 것인지 해결하는 계층이며,
        - 이 계층에서 사용하는 프로토콜이 IP(Internet Protocol)!
        - IP 자체는 비 연결지향적, 신뢰할 수 없는 프로토콜 => 데이터 전송할 때마다 경로 선택 But 일정하지 않은 경로
        - 데이터 전송 도중 경로상 문제 발생 시 다른 경로 선택 But 데이터 손실 or 오류 발생 등에 대한 해결X
        - 오류발생에 대한 대비가 되어있지 않은 프로토콜
    3. TCP/UDP 계층
        - IP 계층에서 알려준 경로 정보를 바탕으로 데이터의 실제 송수신 담당
        - 전송(Transport) 계층
        - **TCP는 신뢰성 있는 데이터의 전송 담당**
        - IP는 오로지 하나의 데이터 패킷(데이터 전송의 기본 단위)이 전송되는 과정에만 중심을 두고 설계됨
        - 여러 개의 데이터 패킷을 전송한다 해도 각각의 패킷이 전송되는 과정은 IP에 의해 진행되므로 전송 순서 및 전송 자체 신뢰X
        - TCP는 데이터의 송수신 확인, 분실된 데이터 재전송 해줌
        - **TCP는 확인 절차를 걸쳐 신뢰성이 없는 IP에 신뢰성을 부여한 프로토콜!**
        - IP 상위 계층에서 호스트 대 호스트의 데이터 송수진 방식을 약속하는 TCP/UDP
    4. APPLICATION 계층
        - 클라이언트와 서버간의 데이터 송수신에 대한 정해진 약속(규칙)들을 APPLICATION 프로토콜이라고 함


- TCP 서버의 함수 호출 순서
    1. socket() : 소켓 생성
    2. bind() : 소켓에 주소 할당
    3. listen() : 연결 요청 대기 상태
    4. accept() : 연결 허용(데이터 입출력용 소켓 생성!!)
    5. read()/write() : 데이터 송수신
    6. close() : 연결 종료

- 연결 요청을 허락하는 서버 소켓, 연결 요청 허락되고 실질적으로 데이터를 주고 받을 수 있는 클라이언트 소켓 두 개의 소켓이 생성되어야 함!

- listen()
    - listen() 호출 되어야 클라이언트가 연결 요청 할 수 있는 상태가 됨!
    - listen() 호출 되어야 클라이언트는 연결 요청을 위해 connect() 호출 가능

    ```c
    int listen(int sock, int backlog);
        // 성공 시 0, 실패 시 -1 리턴
        // sock : "연결 요청 대기 상태"에 두고자 하는 소켓의 파일 디스크립터 전달,
        //      : 이 함수의 인자로 전달된 디스크립터의 소켓이 "서버 소켓(리스닝 소켓)"이 됨
        // backlog : 연결 요청 대키 큐의 크기 정보 전달, 5가 전달되면 큐의 크기가 5가 되어 클라이언트의 연결요청을 5개까지 대기시킬 수 있다!
    ```

    - 서버가 연결 요청 대기 상태에 있다. = 클라이언트가 연결 요청을 했을 때 연결이 수락될 때까지 연결 요청 자체를 대기시킬 수 있는 상태에 있다.
    - 서버 소켓 
        - 연결 요청을 맞이하는 일종의 문지기 역할!
        - 클라이언트의 연결요청을 연결 요청 대기실(연결 요청 대기 큐)로!
        - listen 함수 호출되면 문지기 역할을 하는 서버 소켓이 생성되고, listen 함수 두 번째 인자로 전달되는 정수 크기만큼의 대기실 생성됨
        - 이 대기실이 연결 요청 대기 큐!
        - 클라이언트의 연결 요청을 받아들일 수 있는 상태(서버소켓 & 연결요청 대기 큐 준비 완료)를 연결 요청 대기 상태!

- **accept()**
    - 연결 요청 대기 큐에서 대기 중인 클라이언트의 연결 요청을 수락하는 기능의 함수
    - 호출 성공 시 내부적으로 데이터 입출력에 사용할 **소켓 생성** 하고, 해당 소켓의 파일 디스크립터 반환
    - **accept 함수 호출에 의해 생성된 소켓은 연결 요청을 한 클라이언트 소켓과 자동으로 연결됨!**

    ```c
    int accept(int sock, struct sockaddr* addr, socklen_t* addrlen);
        // 성공 시 생성된 소켓의 파일 디스크립터, 실패 시 -1 리턴
        // sock : 서버 소켓의 파일 디스크립터 전달
        // addr : 연결 요청한 클라이언트의 주소 정보를 담을 변수의 주소 값 전달
        //      : 함수 호출이 완료되면 인자로 전달된 주소의 변수에 클라이언트의 주소 정보 채워짐
        // addrlen : 두 번째 매개변수 addr에 전달된 주소의 변수 크기를 바이트 단위로 전달
        //         : 단, 크기 정보를 변수에 저장한 다음 변수의 주소 값 전달
        //         : 함수 호출 완료 시, 크기 정보로 채워져있던 변수에 클라이언트의 주소 정보 길이가 바이트 단위로 계산되어 채워짐
    ```

    - TCP 클라이언트의 함수 호출 순서
    1. socket() : 소켓 생성
    2. connect() : 연결 요청
    3. read()/write() : 데이터 송수신
    4. close() : 연결 종료

    - **connect()**
        - 클라이언트 소켓 생성 후 서버로 연결을 요청
        - 서버는 listen 함수 호출 이후부터 연결요청 대기 큐 만들어놓으니 그 때부터 클라이언트의 연결 요청이 가능해짐!!

        ```c
        int connect(int sock, struct sockaddr* servaddr, socklen_t addrlen);
            // 성공 시 0, 실패 시 -1 반환
            // sock : 클라이언트 소켓의 파일 디스크립터 반환
            // servaddr :  연결 요청할 서버의 주소 정보를 담은 변수의 주소 값 전달
            // addrlen : 두 번째 매개변수 servaddr에 전달된 주소의 변수 크기를 바이트 단위로 전달
        ```

        - connect() 호출 시 둘 중 한 가지 상황이 되어야 함수 반환(호출 완료)됨!
            1. 서버에 의해 연결 요청이 접수되었다.
            2. 네트워크 단절 등 오류 상황 발생하여 연결요청이 중단되었다.

            - 연결 요청의 접수 = 클라이언트의 연결요청 정보가 서버의 연결요청 대기 큐에 등록된 상황
        

    ![TCP기반 서버,클라이언트의 함수 호출 관계](https://raw.githubusercontent.com/som7199/TCP-IP-2024/main/images/t0001.png)

- echo_server.c / echo_client.c 팀별로 확인해보기
    - ipTIME 관리자 > NAT/라우터 관리 > 포트포워드 설정
        - 규칙이름 : pi
        - 내부 IP 주소 : 라즈베리파이 ip
        - 프로토콜 : TCP
        - 외부포트 : 18080
        - 내부포트 : 18080

        - ./eserver 18080
        - ./eclient 210.119.12.65(서버용 컴퓨터(내 컴)) 18080

- TCP 소켓의 입출력버퍼
    - TCP 소켓의 데이터 송수신에는 경계X
        - 서버가 한번의 write 함수 호출로 40바이트를 전송해도, 클라이언트는 네 번의 read 함수 호출을 통해 10바이트씩 데이터 수신이 가능함
    - write 함수가 호출되는 순간 데이터는 **출력버퍼**로 이동하고,
    - read 함수가 호출되는 순간 **입력버퍼**에 저장된 데이터를 읽어들임

    1. 입출력 버퍼는 TCP 소켓 각각에 대해 별도로 존재
    2. 입출력 버퍼는 소켓 생성 시 자동으로 생성
    3. **소켓을 닫아도 출력버퍼에 남아있는 데이터는 계속해서 전송이 이루어짐**
        - 내 코드에 상관없이 OS가 맡아서 하고 있기 때문에 계속 전송이 이루어짐
    4. **소켓을 닫으면 입력버퍼에 남아있는 데이터는 소멸되어버림**
        - 소켓을 닫으면 read 함수로 데이터를 수신할 수 없기 때문..